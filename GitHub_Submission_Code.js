// Get the processed review data
const reviewData = $input.first().json;
const prData = reviewData.prData;

// Extract repository info
const owner = prData.repository.owner.login;
const repo = prData.repository.name;
const pullNumber = prData.pull_request.number;

// Collect comments that can't be posted as line comments
const commentsForMainReview = [];

// Check for comments that need to be added to main review
Object.keys(reviewData.commentsByFile).forEach(filePath => {
  const fileComments = reviewData.commentsByFile[filePath];
  fileComments.forEach(comment => {
    if (!comment.body || !comment.path) return;
    
    const fileExtension = comment.path.split('.').pop().toLowerCase();
    const supportsLineComments = !['xml', 'json', 'yaml', 'yml', 'md', 'txt', 'png', 'jpg', 'jpeg', 'gif', 'svg'].includes(fileExtension);
    
    if (!supportsLineComments || !comment.line || comment.line <= 0) {
      commentsForMainReview.push({
        file: comment.path,
        comment: comment.body.replace('🤖 **Automated Review**\n\n', '').replace('\n\n---\n*This comment was generated by an automated review system*', '')
      });
    }
  });
});

// Build enhanced main review body
let enhancedReviewBody = reviewData.reviewBody;

if (commentsForMainReview.length > 0) {
  enhancedReviewBody += '\n\n## 📝 Additional Comments\n\n';
  commentsForMainReview.forEach(item => {
    enhancedReviewBody += `**File**: \`${item.file}\`\n${item.comment}\n\n`;
  });
}

// Prepare the main review submission
const mainReviewPayload = {
  body: enhancedReviewBody,
  event: reviewData.reviewState
};

// Prepare individual comments for submission
const commentsToSubmit = [];

// Flatten all comments from all files
Object.keys(reviewData.commentsByFile).forEach(filePath => {
  const fileComments = reviewData.commentsByFile[filePath];
  fileComments.forEach(comment => {
    // Validate comment data before submission
    if (!comment.body || !comment.path) {
      console.warn('Skipping invalid comment:', comment);
      return;
    }
    
    // Check if this is a file that supports line comments
    const fileExtension = comment.path.split('.').pop().toLowerCase();
    const supportsLineComments = !['xml', 'json', 'yaml', 'yml', 'md', 'txt', 'png', 'jpg', 'jpeg', 'gif', 'svg'].includes(fileExtension);
    
    // For files that don't support line comments or when line resolution fails,
    // we'll add the comment to the main review instead
    if (!supportsLineComments || !comment.line || comment.line <= 0) {
      console.log(`Adding comment for ${comment.path} to main review (no line comments supported)`);
      // We'll handle this by adding to main review body instead
      return;
    }
    
    // Ensure line number is valid (GitHub requires line > 0)
    const lineNumber = Math.max(1, comment.line || 1);
    
    commentsToSubmit.push({
      body: comment.body,
      path: comment.path,
      line: lineNumber,
      commit_id: prData.pull_request.head.sha, // Add commit SHA
      position: lineNumber // Use line as position
    });
  });
});

// Create submission URLs
const reviewUrl = `https://api.github.com/repos/${owner}/${repo}/pulls/${pullNumber}/reviews`;
const commentsUrl = `https://api.github.com/repos/${owner}/${repo}/pulls/${pullNumber}/comments`;

// Validate that we have valid data to submit
if (!reviewData.reviewBody || !reviewData.reviewState) {
  console.error('Invalid review data - missing required fields');
  return {
    error: 'Invalid review data - missing required fields',
    summary: {
      totalComments: 0,
      filesReviewed: 0,
      reviewState: 'COMMENT',
      prNumber: pullNumber,
      prUrl: prData.pull_request.html_url
    }
  };
}

// Prepare the response structure
const response = {
  // Main review submission
  mainReview: {
    url: reviewUrl,
    method: 'POST',
    payload: mainReviewPayload
  },
  
  // Individual comments submission (only if there are comments to submit)
  comments: commentsToSubmit.length > 0 ? commentsToSubmit.map(comment => ({
    url: commentsUrl,
    method: 'POST',
    payload: comment
  })) : [],
  
  // Summary info
  summary: {
    totalComments: commentsToSubmit.length, // Use actual submitted comments count
    filesReviewed: reviewData.filesReviewed,
    reviewState: reviewData.reviewState,
    prNumber: pullNumber,
    prUrl: prData.pull_request.html_url
  }
};

// Add a flag to indicate if there are comments to process
response.hasComments = commentsToSubmit.length > 0;

return response;
