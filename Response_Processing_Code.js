// Get OpenAI response
const openAIResponse = $input.first().json;
const prData = $('GitHub Trigger').first().json.body;

// Extract the review data from OpenAI response
let reviewData;
try {
  // Parse the content if it's a string
  if (typeof openAIResponse.message.content === 'string') {
    reviewData = JSON.parse(openAIResponse.message.content);
  } else {
    reviewData = openAIResponse.message.content;
  }
} catch (error) {
  console.error('Error parsing OpenAI response:', error);
  reviewData = {
    overall_review: "Error processing review. Please check the logs.",
    comments: []
  };
}

// Validate response structure
if (!reviewData.comments || !Array.isArray(reviewData.comments)) {
  console.error('Invalid response format from OpenAI');
  reviewData.comments = [];
}

// Group comments by file path
const commentsByFile = {};
reviewData.comments.forEach(comment => {
  if (!commentsByFile[comment.path]) {
    commentsByFile[comment.path] = [];
  }
  
  // Clean and validate comment body
  let cleanBody = comment.body || '';
  
  // Remove any problematic characters or patterns that might cause issues
  cleanBody = cleanBody
    .replace(/[^\x20-\x7E\u00A0-\uFFFF]/g, '') // Remove non-printable characters except extended unicode
    .replace(/\s+/g, ' ') // Normalize whitespace
    .trim();
  
  // Ensure comment body is not empty
  if (!cleanBody) {
    cleanBody = 'Please review this change for compliance with project guidelines.';
  }
  
  commentsByFile[comment.path].push({
    path: comment.path,
    line: comment.line || 1, // Default to line 1 if line is 0 or undefined
    body: `ðŸ¤– **Automated Review**\n\n${cleanBody}\n\n---\n*This comment was generated by an automated review system*`
  });
});

// Create review body
const reviewBody = `## ðŸ¤– Automated Code Review\n\n${reviewData.overall_review}\n\n**Files Reviewed**: ${Object.keys(commentsByFile).length}\n**Total Comments**: ${reviewData.comments.length}`;

// Determine review state based on comments
function determineReviewState(commentsCount) {
  if (commentsCount === 0) {
    return 'APPROVE'; // Approve if no issues found
  } else if (commentsCount <= 3) {
    return 'COMMENT'; // Comment for minor issues
  } else {
    return 'REQUEST_CHANGES'; // Request changes for major issues
  }
}

const reviewState = determineReviewState(reviewData.comments.length);

return {
  reviewBody: reviewBody,
  reviewState: reviewState,
  commentsByFile: commentsByFile,
  totalComments: reviewData.comments.length,
  filesReviewed: Object.keys(commentsByFile).length,
  prData: prData
};
